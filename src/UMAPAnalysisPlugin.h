#pragma once

#include <AnalysisPlugin.h>

#include <PointData/PointData.h>

#include "SettingsAction.h"

#include "graphics/Vector2f.h"

#include <QRandomGenerator>
#include <QtMath>

/** All plugin related classes are in the HDPS plugin namespace */
using namespace mv::plugin;

/** Vector classes used in this plugin are in the HDPS namespace */
using namespace mv;

/**
 * UMAP analysis plugin class
 *
 * This analysis plugin class provides acces to the UMAP implementation from
 * https://github.com/LTLA/umappp as an analysis plugin in HDPS
 *
 * UMAP is a neighborhood-based dimensionality reduction similar to t-SNE
 *
 * @authors T. HÃ¶llt
 */
class UMAPAnalysisPlugin : public AnalysisPlugin
{
Q_OBJECT

    /** Describes a data point (position + heading) */
    struct Point
    {
        /** Constructor */
        Point() :
            _positionX(),
            _positionY()
        {
            initialize();
        }

        /** Perform random initialization of position and heading */
        void initialize() {

            // Establish random position
            _positionX = rng.bounded(1.0);
            _positionY = rng.bounded(1.0);
        }

        /** Members */
        float   _positionX;         /** X-position of the data point */
        float   _positionY;         /** Y-position of the data point */

        /** Statics */
        static QRandomGenerator         rng;                    /** Random number generator for generating random points and headings */
        static std::vector<QString>     dimensionNames;         /** Names of the dimensions as the presented in the GUI */
        static std::uint32_t            numberOfDimensions;     /** Number of dimensions */
        static float                    maximumVelocity;        /** Maximum velocity */
    };

public:

    /**
     * Constructor
     * @param factory Pointer to the plugin factory
     */
    UMAPAnalysisPlugin(const PluginFactory* factory);

    /** Destructor */
    ~UMAPAnalysisPlugin() override = default;

    /**
     * This function is called by the core after the analysis plugin has been created
     *
     * Typical implementations of this function focus on the generation of output data
     * and responding to events which are sent by the core.
    */
    void init() override;

    /**
     * Invoked when a points data event occurs
     * @param dataEvent Data event which occurred
     */
    void onDataEvent(mv::DatasetEvent* dataEvent);

private:
    SettingsAction      _settingsAction;    /** The place where settings are stored (more info in SettingsAction.h) */
    std::vector<float>  _embedding;         /** The output embedding as generated by this plugin  */
    QVector<Vector2f>   _pointHeadings;     /** The start point headings */
    int                 _outDimensions;     /** The number of dimensions to reduce to */
    Dataset<Points>     _outputPoints;
    
};

/**
 * UMAP analysis plugin factory class
 *
 * Note: Factory does not need to be altered (merely responsible for generating new plugins when requested)
 */
class UMAPAnalysisPluginFactory : public AnalysisPluginFactory
{
    Q_INTERFACES(mv::plugin::AnalysisPluginFactory mv::plugin::PluginFactory)
    Q_OBJECT
    Q_PLUGIN_METADATA(IID   "nl.ManiVault.UMAPAnalysisPlugin"
                      FILE  "UMAPAnalysisPlugin.json")

public:

    /** Default constructor */
    UMAPAnalysisPluginFactory() {}

    /** Destructor */
    ~UMAPAnalysisPluginFactory() override {}

    /** Creates an instance of the UMAP analysis plugin */
    AnalysisPlugin* produce() override;

    /** Returns the data types that are supported by the UMAP analysis plugin */
    mv::DataTypes supportedDataTypes() const override;

    /** Enable right-click on data set to open analysis */
    PluginTriggerActions getPluginTriggerActions(const mv::Datasets& datasets) const override;
};
